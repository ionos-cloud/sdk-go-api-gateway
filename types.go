// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	core "go-mod-path/generated/go/core"
	time "time"
)

// The Error object is used to represent an error response from the API.
type Error struct {
	// The HTTP status code of the operation.
	HttpStatus *int `json:"httpStatus,omitempty" url:"httpStatus,omitempty"`
	// A list of error messages.
	Messages []*ErrorMessagesItem `json:"messages,omitempty" url:"messages,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *Error) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *Error) UnmarshalJSON(data []byte) error {
	type unmarshaler Error
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = Error(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *Error) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorMessagesItem struct {
	// Application internal error code
	ErrorCode *string `json:"errorCode,omitempty" url:"errorCode,omitempty"`
	// A human readable explanation specific to this occurrence of the
	// problem.
	Message *string `json:"message,omitempty" url:"message,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (e *ErrorMessagesItem) GetExtraProperties() map[string]interface{} {
	return e.extraProperties
}

func (e *ErrorMessagesItem) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorMessagesItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorMessagesItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *e)
	if err != nil {
		return err
	}
	e.extraProperties = extraProperties

	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorMessagesItem) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// An API gateway consists of the generic rules and configurations of an API Gateway.
type Gateway struct {
	Name string `json:"name" url:"name"`
	// This field enables or disables the collection and reporting of logs for observability of this instance.
	Logs *bool `json:"logs,omitempty" url:"logs,omitempty"`
	// This field enables or disables the collection and reporting of metrics for observability of this instance.
	Metrics       *bool                       `json:"metrics,omitempty" url:"metrics,omitempty"`
	CustomDomains []*GatewayCustomDomainsItem `json:"customDomains,omitempty" url:"customDomains,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *Gateway) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *Gateway) UnmarshalJSON(data []byte) error {
	type unmarshaler Gateway
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = Gateway(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *Gateway) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The custom domain that the API Gateway instance should listen on.
type GatewayCustomDomainsItem struct {
	// The domain name of the distribution. Field is validated as FQDN [according to RFC1123](https://pkg.go.dev/github.com/go-playground/validator/v10#hdr-Hostname_RFC_1123).
	Name *string `json:"name,omitempty" url:"name,omitempty"`
	// The ID of the certificate to use for the distribution.
	CertificateId *string `json:"certificateId,omitempty" url:"certificateId,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GatewayCustomDomainsItem) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GatewayCustomDomainsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler GatewayCustomDomainsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GatewayCustomDomainsItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GatewayCustomDomainsItem) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GatewayRead struct {
	// The ID (UUID) of the Gateway.
	Id string `json:"id" url:"id"`
	// The type of the resource.
	// The URL of the Gateway.
	Href       string                `json:"href" url:"href"`
	Metadata   *MetadataWithEndpoint `json:"metadata,omitempty" url:"metadata,omitempty"`
	Properties *Gateway              `json:"properties,omitempty" url:"properties,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GatewayRead) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GatewayRead) Type() string {
	return g.type_
}

func (g *GatewayRead) UnmarshalJSON(data []byte) error {
	type embed GatewayRead
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GatewayRead(unmarshaler.embed)
	if unmarshaler.Type != "gateway" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "gateway", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GatewayRead) MarshalJSON() ([]byte, error) {
	type embed GatewayRead
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "gateway",
	}
	return json.Marshal(marshaler)
}

func (g *GatewayRead) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type GatewayReadList struct {
	Offset Offset `json:"offset" url:"offset"`
	Limit  Limit  `json:"limit" url:"limit"`
	Links  *Links `json:"_links,omitempty" url:"_links,omitempty"`
	// ID of the list of Gateway resources.
	Id string `json:"id" url:"id"`
	// The type of the resource.
	// The URL of the list of Gateway resources.
	Href string `json:"href" url:"href"`
	// The list of Gateway resources.
	Items []*GatewayRead `json:"items,omitempty" url:"items,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (g *GatewayReadList) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GatewayReadList) Type() string {
	return g.type_
}

func (g *GatewayReadList) UnmarshalJSON(data []byte) error {
	type embed GatewayReadList
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*g = GatewayReadList(unmarshaler.embed)
	if unmarshaler.Type != "collection" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", g, "collection", unmarshaler.Type)
	}
	g.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *g, "type")
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties

	g._rawJSON = json.RawMessage(data)
	return nil
}

func (g *GatewayReadList) MarshalJSON() ([]byte, error) {
	type embed GatewayReadList
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*g),
		Type:  "collection",
	}
	return json.Marshal(marshaler)
}

func (g *GatewayReadList) String() string {
	if len(g._rawJSON) > 0 {
		if value, err := core.StringifyJSON(g._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// The limit specified in the request (if none was specified, use the
// endpoint's default pagination limit).
type Limit = int

// URLs to navigate the different pages. As of now we always only return a
// single page.
type Links struct {
	// URL (with offset and limit parameters) of the previous page; only
	// present if offset is greater than 0.
	Prev *string `json:"prev,omitempty" url:"prev,omitempty"`
	// URL (with offset and limit parameters) of the current page.
	Self *string `json:"self,omitempty" url:"self,omitempty"`
	// URL (with offset and limit parameters) of the next page; only
	// present if offset + limit is less than the total number of elements.
	Next *string `json:"next,omitempty" url:"next,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (l *Links) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *Links) UnmarshalJSON(data []byte) error {
	type unmarshaler Links
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = Links(value)

	extraProperties, err := core.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties

	l._rawJSON = json.RawMessage(data)
	return nil
}

func (l *Links) String() string {
	if len(l._rawJSON) > 0 {
		if value, err := core.StringifyJSON(l._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Metadata of the resource.
type Metadata struct {
	// The ISO 8601 creation timestamp.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty"`
	// Unique name of the identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty" url:"createdBy,omitempty"`
	// Unique id of the identity that created the resource.
	CreatedByUserId *string `json:"createdByUserId,omitempty" url:"createdByUserId,omitempty"`
	// The ISO 8601 modified timestamp.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty"`
	// Unique name of the identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty" url:"lastModifiedBy,omitempty"`
	// Unique id of the identity that last modified the resource.
	LastModifiedByUserId *string `json:"lastModifiedByUserId,omitempty" url:"lastModifiedByUserId,omitempty"`
	// Unique name of the resource.
	ResourceUrn *string `json:"resourceURN,omitempty" url:"resourceURN,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *Metadata) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *Metadata) UnmarshalJSON(data []byte) error {
	type embed Metadata
	var unmarshaler = struct {
		embed
		CreatedDate      *core.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *core.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = Metadata(unmarshaler.embed)
	m.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	m.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *Metadata) MarshalJSON() ([]byte, error) {
	type embed Metadata
	var marshaler = struct {
		embed
		CreatedDate      *core.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *core.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed:            embed(*m),
		CreatedDate:      core.NewOptionalDateTime(m.CreatedDate),
		LastModifiedDate: core.NewOptionalDateTime(m.LastModifiedDate),
	}
	return json.Marshal(marshaler)
}

func (m *Metadata) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetadataWithEndpoint struct {
	// The ISO 8601 creation timestamp.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty"`
	// Unique name of the identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty" url:"createdBy,omitempty"`
	// Unique id of the identity that created the resource.
	CreatedByUserId *string `json:"createdByUserId,omitempty" url:"createdByUserId,omitempty"`
	// The ISO 8601 modified timestamp.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty"`
	// Unique name of the identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty" url:"lastModifiedBy,omitempty"`
	// Unique id of the identity that last modified the resource.
	LastModifiedByUserId *string `json:"lastModifiedByUserId,omitempty" url:"lastModifiedByUserId,omitempty"`
	// Unique name of the resource.
	ResourceUrn *string `json:"resourceURN,omitempty" url:"resourceURN,omitempty"`
	// The status of the object. The status can be:
	//
	// - `AVAILABLE` - resource exists and is healthy.
	// - `PROVISIONING` - resource is being created or updated.
	// - `DESTROYING` - delete command was issued, the resource is being deleted.
	// - `FAILED` - resource failed, details in `failureMessage`.
	Status MetadataWithStatusStatus `json:"status" url:"status"`
	// The message of the failure if the status is `FAILED`.
	StatusMessage *string `json:"statusMessage,omitempty" url:"statusMessage,omitempty"`
	// The public endpoint of the API Gateway instance.
	PublicEndpoint string `json:"publicEndpoint" url:"publicEndpoint"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetadataWithEndpoint) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataWithEndpoint) UnmarshalJSON(data []byte) error {
	type embed MetadataWithEndpoint
	var unmarshaler = struct {
		embed
		CreatedDate      *core.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *core.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MetadataWithEndpoint(unmarshaler.embed)
	m.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	m.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataWithEndpoint) MarshalJSON() ([]byte, error) {
	type embed MetadataWithEndpoint
	var marshaler = struct {
		embed
		CreatedDate      *core.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *core.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed:            embed(*m),
		CreatedDate:      core.NewOptionalDateTime(m.CreatedDate),
		LastModifiedDate: core.NewOptionalDateTime(m.LastModifiedDate),
	}
	return json.Marshal(marshaler)
}

func (m *MetadataWithEndpoint) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

type MetadataWithStatus struct {
	// The ISO 8601 creation timestamp.
	CreatedDate *time.Time `json:"createdDate,omitempty" url:"createdDate,omitempty"`
	// Unique name of the identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty" url:"createdBy,omitempty"`
	// Unique id of the identity that created the resource.
	CreatedByUserId *string `json:"createdByUserId,omitempty" url:"createdByUserId,omitempty"`
	// The ISO 8601 modified timestamp.
	LastModifiedDate *time.Time `json:"lastModifiedDate,omitempty" url:"lastModifiedDate,omitempty"`
	// Unique name of the identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty" url:"lastModifiedBy,omitempty"`
	// Unique id of the identity that last modified the resource.
	LastModifiedByUserId *string `json:"lastModifiedByUserId,omitempty" url:"lastModifiedByUserId,omitempty"`
	// Unique name of the resource.
	ResourceUrn *string `json:"resourceURN,omitempty" url:"resourceURN,omitempty"`
	// The status of the object. The status can be:
	//
	// - `AVAILABLE` - resource exists and is healthy.
	// - `PROVISIONING` - resource is being created or updated.
	// - `DESTROYING` - delete command was issued, the resource is being deleted.
	// - `FAILED` - resource failed, details in `failureMessage`.
	Status MetadataWithStatusStatus `json:"status" url:"status"`
	// The message of the failure if the status is `FAILED`.
	StatusMessage *string `json:"statusMessage,omitempty" url:"statusMessage,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (m *MetadataWithStatus) GetExtraProperties() map[string]interface{} {
	return m.extraProperties
}

func (m *MetadataWithStatus) UnmarshalJSON(data []byte) error {
	type embed MetadataWithStatus
	var unmarshaler = struct {
		embed
		CreatedDate      *core.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *core.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed: embed(*m),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*m = MetadataWithStatus(unmarshaler.embed)
	m.CreatedDate = unmarshaler.CreatedDate.TimePtr()
	m.LastModifiedDate = unmarshaler.LastModifiedDate.TimePtr()

	extraProperties, err := core.ExtractExtraProperties(data, *m)
	if err != nil {
		return err
	}
	m.extraProperties = extraProperties

	m._rawJSON = json.RawMessage(data)
	return nil
}

func (m *MetadataWithStatus) MarshalJSON() ([]byte, error) {
	type embed MetadataWithStatus
	var marshaler = struct {
		embed
		CreatedDate      *core.DateTime `json:"createdDate,omitempty"`
		LastModifiedDate *core.DateTime `json:"lastModifiedDate,omitempty"`
	}{
		embed:            embed(*m),
		CreatedDate:      core.NewOptionalDateTime(m.CreatedDate),
		LastModifiedDate: core.NewOptionalDateTime(m.LastModifiedDate),
	}
	return json.Marshal(marshaler)
}

func (m *MetadataWithStatus) String() string {
	if len(m._rawJSON) > 0 {
		if value, err := core.StringifyJSON(m._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(m); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", m)
}

// The status of the object. The status can be:
//
// - `AVAILABLE` - resource exists and is healthy.
// - `PROVISIONING` - resource is being created or updated.
// - `DESTROYING` - delete command was issued, the resource is being deleted.
// - `FAILED` - resource failed, details in `failureMessage`.
type MetadataWithStatusStatus string

const (
	MetadataWithStatusStatusProvisioning MetadataWithStatusStatus = "PROVISIONING"
	MetadataWithStatusStatusDestroying   MetadataWithStatusStatus = "DESTROYING"
	MetadataWithStatusStatusAvailable    MetadataWithStatusStatus = "AVAILABLE"
	MetadataWithStatusStatusFailed       MetadataWithStatusStatus = "FAILED"
)

func NewMetadataWithStatusStatusFromString(s string) (MetadataWithStatusStatus, error) {
	switch s {
	case "PROVISIONING":
		return MetadataWithStatusStatusProvisioning, nil
	case "DESTROYING":
		return MetadataWithStatusStatusDestroying, nil
	case "AVAILABLE":
		return MetadataWithStatusStatusAvailable, nil
	case "FAILED":
		return MetadataWithStatusStatusFailed, nil
	}
	var t MetadataWithStatusStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (m MetadataWithStatusStatus) Ptr() *MetadataWithStatusStatus {
	return &m
}

// The offset specified in the request (if none was specified, the default
// offset is 0).
type Offset = int

// Pagination information. The offset and limit parameters are used to
// navigate the list of elements. The \_links object contains URLs to
// navigate the different pages.
type Pagination struct {
	Offset Offset `json:"offset" url:"offset"`
	Limit  Limit  `json:"limit" url:"limit"`
	Links  *Links `json:"_links,omitempty" url:"_links,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (p *Pagination) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Pagination) UnmarshalJSON(data []byte) error {
	type unmarshaler Pagination
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*p = Pagination(value)

	extraProperties, err := core.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties

	p._rawJSON = json.RawMessage(data)
	return nil
}

func (p *Pagination) String() string {
	if len(p._rawJSON) > 0 {
		if value, err := core.StringifyJSON(p._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}

// A route is a rule that maps an incoming request to a specific backend service.
type Route struct {
	// The name of the route.
	Name string `json:"name" url:"name"`
	// This field specifies the protocol used by the ingress to route traffic to the backend service.
	Type string `json:"type" url:"type"`
	// The paths that the route should match.
	Paths []string `json:"paths,omitempty" url:"paths,omitempty"`
	// The HTTP methods that the route should match.
	Methods []RouteMethodsItem `json:"methods,omitempty" url:"methods,omitempty"`
	// To enable websocket support.
	Websocket *bool                 `json:"websocket,omitempty" url:"websocket,omitempty"`
	Upstreams []*RouteUpstreamsItem `json:"upstreams,omitempty" url:"upstreams,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *Route) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *Route) UnmarshalJSON(data []byte) error {
	type unmarshaler Route
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = Route(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *Route) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RouteMethodsItem string

const (
	RouteMethodsItemGet     RouteMethodsItem = "GET"
	RouteMethodsItemPost    RouteMethodsItem = "POST"
	RouteMethodsItemPut     RouteMethodsItem = "PUT"
	RouteMethodsItemDelete  RouteMethodsItem = "DELETE"
	RouteMethodsItemPatch   RouteMethodsItem = "PATCH"
	RouteMethodsItemOptions RouteMethodsItem = "OPTIONS"
	RouteMethodsItemHead    RouteMethodsItem = "HEAD"
	RouteMethodsItemConnect RouteMethodsItem = "CONNECT"
	RouteMethodsItemTrace   RouteMethodsItem = "TRACE"
)

func NewRouteMethodsItemFromString(s string) (RouteMethodsItem, error) {
	switch s {
	case "GET":
		return RouteMethodsItemGet, nil
	case "POST":
		return RouteMethodsItemPost, nil
	case "PUT":
		return RouteMethodsItemPut, nil
	case "DELETE":
		return RouteMethodsItemDelete, nil
	case "PATCH":
		return RouteMethodsItemPatch, nil
	case "OPTIONS":
		return RouteMethodsItemOptions, nil
	case "HEAD":
		return RouteMethodsItemHead, nil
	case "CONNECT":
		return RouteMethodsItemConnect, nil
	case "TRACE":
		return RouteMethodsItemTrace, nil
	}
	var t RouteMethodsItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RouteMethodsItem) Ptr() *RouteMethodsItem {
	return &r
}

type RouteRead struct {
	// The ID (UUID) of the Route.
	Id string `json:"id" url:"id"`
	// The type of the resource.
	// The URL of the Route.
	Href       string                `json:"href" url:"href"`
	Metadata   *MetadataWithEndpoint `json:"metadata,omitempty" url:"metadata,omitempty"`
	Properties *Route                `json:"properties,omitempty" url:"properties,omitempty"`
	type_      string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RouteRead) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RouteRead) Type() string {
	return r.type_
}

func (r *RouteRead) UnmarshalJSON(data []byte) error {
	type embed RouteRead
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RouteRead(unmarshaler.embed)
	if unmarshaler.Type != "route" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "route", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RouteRead) MarshalJSON() ([]byte, error) {
	type embed RouteRead
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "route",
	}
	return json.Marshal(marshaler)
}

func (r *RouteRead) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RouteReadList struct {
	Offset Offset `json:"offset" url:"offset"`
	Limit  Limit  `json:"limit" url:"limit"`
	Links  *Links `json:"_links,omitempty" url:"_links,omitempty"`
	// ID of the list of Route resources.
	Id string `json:"id" url:"id"`
	// The type of the resource.
	// The URL of the list of Route resources.
	Href string `json:"href" url:"href"`
	// The list of Route resources.
	Items []*RouteRead `json:"items,omitempty" url:"items,omitempty"`
	type_ string

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RouteReadList) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RouteReadList) Type() string {
	return r.type_
}

func (r *RouteReadList) UnmarshalJSON(data []byte) error {
	type embed RouteReadList
	var unmarshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*r = RouteReadList(unmarshaler.embed)
	if unmarshaler.Type != "collection" {
		return fmt.Errorf("unexpected value for literal on type %T; expected %v got %v", r, "collection", unmarshaler.Type)
	}
	r.type_ = unmarshaler.Type

	extraProperties, err := core.ExtractExtraProperties(data, *r, "type")
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RouteReadList) MarshalJSON() ([]byte, error) {
	type embed RouteReadList
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "collection",
	}
	return json.Marshal(marshaler)
}

func (r *RouteReadList) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

type RouteUpstreamsItem struct {
	// The target URL of the upstream.
	Scheme RouteUpstreamsItemScheme `json:"scheme" url:"scheme"`
	// The load balancer algorithm.
	Loadbalancer string `json:"loadbalancer" url:"loadbalancer"`
	// The host of the upstream. Field is validated as hostname [according to RFC1123](https://pkg.go.dev/github.com/go-playground/validator/v10#hdr-Hostname_RFC_1123).
	Host string `json:"host" url:"host"`
	// The port of the upstream.
	Port int `json:"port" url:"port"`
	// Weight with which to split traffic to the upstream.
	Weight *int `json:"weight,omitempty" url:"weight,omitempty"`

	extraProperties map[string]interface{}
	_rawJSON        json.RawMessage
}

func (r *RouteUpstreamsItem) GetExtraProperties() map[string]interface{} {
	return r.extraProperties
}

func (r *RouteUpstreamsItem) UnmarshalJSON(data []byte) error {
	type unmarshaler RouteUpstreamsItem
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RouteUpstreamsItem(value)

	extraProperties, err := core.ExtractExtraProperties(data, *r)
	if err != nil {
		return err
	}
	r.extraProperties = extraProperties

	r._rawJSON = json.RawMessage(data)
	return nil
}

func (r *RouteUpstreamsItem) String() string {
	if len(r._rawJSON) > 0 {
		if value, err := core.StringifyJSON(r._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(r); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", r)
}

// The target URL of the upstream.
type RouteUpstreamsItemScheme string

const (
	RouteUpstreamsItemSchemeHttp  RouteUpstreamsItemScheme = "http"
	RouteUpstreamsItemSchemeHttps RouteUpstreamsItemScheme = "https"
	RouteUpstreamsItemSchemeGrpc  RouteUpstreamsItemScheme = "grpc"
	RouteUpstreamsItemSchemeGrpcs RouteUpstreamsItemScheme = "grpcs"
)

func NewRouteUpstreamsItemSchemeFromString(s string) (RouteUpstreamsItemScheme, error) {
	switch s {
	case "http":
		return RouteUpstreamsItemSchemeHttp, nil
	case "https":
		return RouteUpstreamsItemSchemeHttps, nil
	case "grpc":
		return RouteUpstreamsItemSchemeGrpc, nil
	case "grpcs":
		return RouteUpstreamsItemSchemeGrpcs, nil
	}
	var t RouteUpstreamsItemScheme
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RouteUpstreamsItemScheme) Ptr() *RouteUpstreamsItemScheme {
	return &r
}
